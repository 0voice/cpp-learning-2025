# 进阶基础篇
## 一、STL（标准模板库）
STL（Standard Template Library）是C++的核心库，封装了常用的数据结构（容器）和算法，遵循“泛型编程”思想，是面试高频考点。核心组件：**容器（Container）、迭代器（Iterator）、算法（Algorithm）**。

### 1. 常用容器
容器是存储数据的“容器”，按底层实现分为**序列式容器**（有序存储）和**关联式容器**（按键值对/唯一值存储），核心容器对比：

| 容器类型       | 具体容器               | 底层实现         | 核心特点                                                                 | 适用场景                     |
|----------------|------------------------|------------------|--------------------------------------------------------------------------|------------------------------|
| 序列式容器     | `vector`               | 动态数组         | 随机访问O(1)、尾部插入/删除O(1)、中间插入/删除O(n)、空间连续             | 频繁访问、尾部增删（最常用） |
|                | `list`                 | 双向链表         | 随机访问O(n)、任意位置插入/删除O(1)、空间不连续、无容量概念             | 频繁中间增删                 |
|                | `deque`                | 分段动态数组     | 随机访问O(1)、首尾插入/删除O(1)、中间插入/删除O(n)、支持扩容不移动元素   | 首尾频繁增删、偶尔随机访问   |
| 关联式容器（有序） | `map`                  | 红黑树           | 按键有序（默认升序）、键唯一、插入/删除/查找O(log n)、键值对存储         | 需有序键值对、去重、频繁查找 |
|                | `set`                  | 红黑树           | 元素有序（默认升序）、元素唯一、插入/删除/查找O(log n)、仅存值           | 需有序集合、去重             |
|                | `multimap`             | 红黑树           | 按键有序、键可重复、插入/删除/查找O(log n)                               | 有序键值对、允许重复键       |
|                | `multiset`             | 红黑树           | 元素有序、元素可重复、插入/删除/查找O(log n)                             | 有序集合、允许重复元素       |
| 关联式容器（无序） | `unordered_map`        | 哈希表（hash table） | 按键无序、键唯一、插入/删除/查找平均O(1)、最坏O(n)、键值对存储           | 高频查找、无需有序（推荐）   |
|                | `unordered_set`        | 哈希表           | 元素无序、元素唯一、插入/删除/查找平均O(1)、最坏O(n)、仅存值             | 高频去重、无需有序（推荐）   |
|                | `unordered_multimap`   | 哈希表           | 按键无序、键可重复、平均O(1)                                             | 无序键值对、允许重复键       |
|                | `unordered_multiset`   | 哈希表           | 元素无序、元素可重复、平均O(1)                                           | 无序集合、允许重复元素       |

#### 核心容器使用示例
##### （1）`vector`（动态数组，最常用）
```cpp
#include <vector>
#include <algorithm> // 包含sort等算法

int main() {
  // 初始化
  vector<int> vec1; // 空vector
  vector<int> vec2(5, 0); // 5个元素，均为0 → [0,0,0,0,0]
  vector<int> vec3 = {1, 2, 3, 4, 5}; // 列表初始化（C++11+）

  // 增删改查
  vec3.push_back(6); // 尾部插入 → [1,2,3,4,5,6]
  vec3.pop_back(); // 尾部删除 → [1,2,3,4,5]
  vec3[2] = 10; // 随机访问修改 → [1,2,10,4,5]
  cout << vec3.at(3); // 安全访问（越界抛异常）→ 4

  // 遍历方式
  // 1. 下标遍历
  for (int i = 0; i < vec3.size(); i++) {
    cout << vec3[i] << " ";
  }

  // 2. 迭代器遍历
  for (vector<int>::iterator it = vec3.begin(); it != vec3.end(); it++) {
    cout << *it << " "; // 迭代器解引用
  }

  // 3. 范围for（C++11+）
  for (int num : vec3) {
    cout << num << " ";
  }

  // 常用操作
  vec3.sort(vec3.begin(), vec3.end()); // 排序（需#include <algorithm>）
  vec3.empty(); // 判断是否为空
  vec3.clear(); // 清空所有元素（容量不变）
  vec3.reserve(10); // 预分配容量（避免频繁扩容）
  return 0;
}
```

##### （2）`unordered_map`（哈希表键值对，高频使用）
```cpp
#include <unordered_map>
#include <string>

int main() {
  unordered_map<string, int> scoreMap;

  // 插入键值对
  scoreMap["Math"] = 90;
  scoreMap.insert({"English", 85}); // 列表插入
  scoreMap.emplace("Chinese", 95); // 原地构造（更高效）

  // 查找（核心操作）
  auto it = scoreMap.find("Math");
  if (it != scoreMap.end()) {
    cout << "Math成绩：" << it->second << endl; // 访问值 → 90
  }

  // 遍历
  for (const auto& pair : scoreMap) {
    cout << pair.first << ": " << pair.second << endl; // first=键，second=值
  }

  // 删改
  scoreMap["English"] = 88; // 修改值
  scoreMap.erase("Chinese"); // 按键删除

  cout << scoreMap.size(); // 元素个数 → 2
  return 0;
}
```

### 2. 迭代器（Iterator）
迭代器是“容器与算法的桥梁”，本质是封装了指针的对象，提供统一的方式遍历容器（屏蔽不同容器的底层差异）。

#### （1）迭代器类型
| 迭代器类型       | 功能                                                                 | 支持容器                     |
|------------------|----------------------------------------------------------------------|------------------------------|
| 输入迭代器（Input Iterator） | 只读、单向遍历（仅++）                                               | 所有容器                     |
| 输出迭代器（Output Iterator） | 只写、单向遍历（仅++）                                               | 所有容器                     |
| 前向迭代器（Forward Iterator） | 可读可写、单向遍历（++）                                             | `forward_list`、`unordered_*` |
| 双向迭代器（Bidirectional Iterator） | 可读可写、双向遍历（++/--）                                   | `list`、`map`、`set`         |
| 随机访问迭代器（Random Access Iterator） | 可读可写、随机访问（[]、+/-）                               | `vector`、`deque`、数组       |

#### （2）迭代器使用规范
- 容器的`begin()`返回指向**第一个元素**的迭代器，`end()`返回指向**最后一个元素的下一个位置**的迭代器（“尾后迭代器”，不可解引用）；
- 常量迭代器（`const_iterator`）：只能读取元素，不能修改（适用于`const`容器或只读场景）；
- C++11+新增`cbegin()`/`cend()`（直接返回常量迭代器）、`rbegin()`/`rend()`（反向迭代器，从尾到头遍历）。

#### （3）迭代器失效（面试高频考点）
迭代器失效是指迭代器指向的内存位置无效（如元素被删除、容器扩容），继续使用会导致程序崩溃或逻辑错误，核心失效场景：

| 容器         | 失效场景                                                                 |
|--------------|--------------------------------------------------------------------------|
| `vector`     | 1. 插入元素导致扩容（重新分配内存，所有迭代器失效）；2. 中间插入/删除（插入/删除点后迭代器失效）；3. `clear()`后所有迭代器失效 |
| `list`       | 1. 仅删除元素的迭代器失效，其他迭代器不受影响；2. 插入元素不影响任何迭代器 |
| `unordered_*` | 1. 插入元素导致哈希表重建（负载因子超过阈值），所有迭代器失效；2. 删除元素仅当前迭代器失效 |
| `map`/`set`  | 1. 删除元素的迭代器失效，其他迭代器不受影响；2. 插入元素不影响任何迭代器 |

**规避方案**：
- 迭代器失效后，重新获取有效迭代器（如`vector`插入后不复用之前的迭代器）；
- 删除元素时，利用返回值更新迭代器（如`list.erase(it)`返回下一个有效迭代器）：
  ```cpp
  // list删除元素的正确方式（避免迭代器失效）
  list<int> lst = {1,2,3,4,5};
  for (auto it = lst.begin(); it != lst.end(); ) {
    if (*it % 2 == 0) {
      it = lst.erase(it); // erase返回下一个有效迭代器，不++
    } else {
      it++;
    }
  }
  ```

### 3. 常用算法
STL算法封装了常用的操作（排序、查找、计数等），定义在`<algorithm>`头文件中，大多通过迭代器操作容器，支持自定义逻辑（配合lambda）。

#### 核心算法示例
| 算法功能       | 函数名                | 示例代码                                                                 |
|----------------|-----------------------|--------------------------------------------------------------------------|
| 排序           | `sort()`              | `sort(vec.begin(), vec.end());`（默认升序）；`sort(vec.begin(), vec.end(), greater<int>());`（降序） |
| 查找           | `find()`              | `auto it = find(vec.begin(), vec.end(), 3);`（找到返回迭代器，否则返回`end()`） |
| 计数           | `count()`             | `int cnt = count(vec.begin(), vec.end(), 2);`（统计元素2的个数）          |
| 遍历           | `for_each()`          | `for_each(vec.begin(), vec.end(), [](int num){ cout << num << " "; });`（配合lambda） |
| 查找满足条件元素 | `find_if()`           | `auto it = find_if(vec.begin(), vec.end(), [](int num){ return num > 5; });`（找第一个大于5的元素） |
| 去重           | `unique()`            | `vec.erase(unique(vec.begin(), vec.end()), vec.end());`（需先排序，再删除重复元素） |
| 反转           | `reverse()`           | `reverse(vec.begin(), vec.end());`（反转容器元素顺序）                     |
| 累加           | `accumulate()`        | `int sum = accumulate(vec.begin(), vec.end(), 0);`（求和，需#include <numeric>） |

**示例：综合使用算法+lambda**
```cpp
#include <vector>
#include <algorithm>
#include <numeric>
#include <iostream>
using namespace std;

int main() {
  vector<int> vec = {3,1,4,1,5,9,2,6};

  // 1. 排序（降序）
  sort(vec.begin(), vec.end(), [](int a, int b){ return a > b; }); 
  // 结果：[9,6,5,4,3,2,1,1]

  // 2. 去重（先排序后去重）
  vec.erase(unique(vec.begin(), vec.end()), vec.end()); 
  // 结果：[9,6,5,4,3,2,1]

  // 3. 遍历输出（for_each+lambda）
  for_each(vec.begin(), vec.end(), [](int num){
    cout << num << " "; // 输出：9 6 5 4 3 2 1
  });

  // 4. 统计大于3的元素个数
  int cnt = count_if(vec.begin(), vec.end(), [](int num){ return num > 3; });
  cout << "\n大于3的元素个数：" << cnt; // 输出：4

  // 5. 累加所有元素
  int sum = accumulate(vec.begin(), vec.end(), 0);
  cout << "\n元素总和：" << sum; // 输出：30

  return 0;
}
```

### 4. Lambda配合STL
Lambda（匿名函数）是C++11+的核心特性，可直接嵌入代码中，无需单独定义函数，完美配合STL算法实现自定义逻辑（如排序规则、查找条件）。

#### Lambda语法回顾
```cpp
[捕获列表](参数列表) -> 返回值类型 { 函数体 }
// 简化：返回值类型可省略（编译器自动推导），无参数时参数列表可省略
```

#### 捕获列表核心用法
| 捕获方式 | 含义                                                                 |
|----------|----------------------------------------------------------------------|
| `[]`     | 不捕获任何外部变量                                                   |
| `[=]`    | 值捕获（拷贝外部变量，函数体内只读）                                 |
| `[&]`    | 引用捕获（引用外部变量，函数体内可修改）                             |
| `[x]`    | 仅值捕获变量x                                                       |
| `[&y]`   | 仅引用捕获变量y                                                     |
| `[=, &z]`| 除z外，其他变量值捕获；z引用捕获                                     |
| `[this]` | 类成员函数中使用，捕获当前对象（可访问成员变量/函数）                 |

#### 实战示例：Lambda+STL排序/查找
```cpp
#include <vector>
#include <algorithm>
#include <string>

struct Student {
  string name;
  int age;
  int score;
};

int main() {
  vector<Student> students = {
    {"Tom", 18, 90},
    {"Jerry", 17, 85},
    {"Alice", 19, 95}
  };

  // 1. 按分数降序排序（lambda作为排序规则）
  sort(students.begin(), students.end(), [](const Student& a, const Student& b){
    return a.score > b.score; // 分数高的在前
  });

  // 2. 查找年龄>=18且分数>=90的学生
  auto it = find_if(students.begin(), students.end(), [](const Student& s){
    return s.age >= 18 && s.score >= 90;
  });
  if (it != students.end()) {
    cout << "找到符合条件的学生：" << it->name << endl; // 输出Alice
  }

  // 3. 引用捕获外部变量，修改学生分数
  int addScore = 5;
  for_each(students.begin(), students.end(), [&addScore](Student& s){
    s.score += addScore; // 所有学生加5分
  });

  return 0;
}
```

## 二、文件IO
文件IO用于实现“数据持久化”（将数据存储到磁盘文件，或从文件读取数据），C++提供两种方式：**C风格文件IO（`<cstdio>`）** 和 **C++风格文件IO（`<fstream>`）**，推荐使用C++风格（面向对象、类型安全）。

### 1. 核心头文件与类
| 头文件   | 核心类                | 功能                                                                 |
|----------|-----------------------|----------------------------------------------------------------------|
| `<fstream>` | `ifstream`            | 输入文件流（从文件读取数据）                                         |
|          | `ofstream`            | 输出文件流（向文件写入数据）                                         |
|          | `fstream`             | 输入输出文件流（既可读又可写）                                       |

### 2. 打开文件的模式（打开方式）
| 模式标志       | 含义                                                                 |
|----------------|----------------------------------------------------------------------|
| `ios::in`      | 读模式（默认用于`ifstream`）                                         |
| `ios::out`     | 写模式（默认用于`ofstream`），若文件存在则清空，不存在则创建           |
| `ios::app`     | 追加模式（写模式的补充），数据写入文件末尾，不覆盖原有内容             |
| `ios::binary`  | 二进制模式（默认是文本模式），用于读写二进制文件（如图片、视频）       |
| `ios::trunc`   | 截断模式（默认用于`ios::out`），文件存在则清空内容                     |
| `ios::ate`     | 打开文件后，文件指针直接指向文件末尾                                   |

**组合使用示例**：
- `ios::in | ios::out`：读写模式（文件必须存在）；
- `ios::out | ios::app`：追加写入模式；
- `ios::in | ios::binary`：二进制读模式。

### 3. 文本文件读写（最常用）
文本文件存储的是字符序列（人类可读），读写时会自动处理换行符（`\n`）的平台差异（Windows：`\r\n`，Linux：`\n`）。

#### （1）文本文件写入
```cpp
#include <fstream>
#include <string>

int main() {
  // 1. 创建输出文件流对象，打开文件（默认ios::out | ios::trunc）
  ofstream ofs("test.txt"); // 若文件不存在则创建，存在则清空
  if (!ofs.is_open()) { // 检查文件是否成功打开
    cout << "文件打开失败！" << endl;
    return -1;
  }

  // 2. 写入数据（支持<<运算符，与cout类似）
  ofs << "姓名：Tom" << endl;
  ofs << "年龄：18" << endl;
  ofs << "分数：90" << endl;

  // 3. 关闭文件（释放资源，建议手动关闭）
  ofs.close();
  return 0;
}
```

#### （2）文本文件读取
```cpp
#include <fstream>
#include <string>
#include <iostream>
using namespace std;

int main() {
  // 1. 创建输入文件流对象，打开文件（默认ios::in）
  ifstream ifs("test.txt");
  if (!ifs.is_open()) {
    cout << "文件打开失败！" << endl;
    return -1;
  }

  // 2. 读取数据（三种常用方式）
  // 方式1：按字符读取（包括空格、换行）
  char ch;
  while (ifs.get(ch)) { // get()读取单个字符，包括'\n'
    cout << ch;
  }

  // 方式2：按行读取（忽略换行符，推荐）
  string line;
  while (getline(ifs, line)) { // getline()读取一行，存储到string
    cout << line << endl;
  }

  // 方式3：按单词读取（以空格/换行分隔）
  string word;
  while (ifs >> word) {
    cout << word << " ";
  }

  // 3. 关闭文件
  ifs.close();
  return 0;
}
```

### 4. 二进制文件读写
二进制文件存储的是字节序列（人类不可读），适用于存储结构体、图片、视频等数据，读写时需指定`ios::binary`模式，且不会处理换行符。

#### （1）二进制文件写入（存储结构体）
```cpp
#include <fstream>

struct Person {
  char name[20]; // 固定长度（避免string的动态内存问题）
  int age;
  double height;
};

int main() {
  // 打开二进制写模式
  ofstream ofs("person.bin", ios::out | ios::binary);
  if (!ofs.is_open()) return -1;

  // 准备数据
  Person p = {"Tom", 18, 1.75};

  // 写入：reinterpret_cast将Person*转为char*（字节流）
  ofs.write(reinterpret_cast<const char*>(&p), sizeof(Person));

  ofs.close();
  return 0;
}
```

#### （2）二进制文件读取（恢复结构体）
```cpp
#include <fstream>
#include <iostream>
using namespace std;

struct Person {
  char name[20];
  int age;
  double height;
};

int main() {
  // 打开二进制读模式
  ifstream ifs("person.bin", ios::in | ios::binary);
  if (!ifs.is_open()) return -1;

  Person p;
  // 读取：按字节读取到p中
  ifs.read(reinterpret_cast<char*>(&p), sizeof(Person));

  // 输出读取结果
  cout << "姓名：" << p.name << endl;
  cout << "年龄：" << p.age << endl;
  cout << "身高：" << p.height << endl;

  ifs.close();
  return 0;
}
```

### 5. 文件指针操作
文件指针（文件位置指示器）指向当前读写的位置，可通过`seekg()`（读指针）和`seekp()`（写指针）调整位置，配合`tellg()`/`tellp()`获取当前位置。

#### 核心函数
| 函数名         | 功能                                                                 |
|----------------|----------------------------------------------------------------------|
| `seekg(pos, mode)` | 移动读指针到指定位置：pos是偏移量，mode是基准（`ios::beg`：文件开头；`ios::cur`：当前位置；`ios::end`：文件末尾） |
| `seekp(pos, mode)` | 移动写指针（用法同seekg）                                             |
| `tellg()`      | 返回读指针当前位置（字节数，从文件开头算起）                           |
| `tellp()`      | 返回写指针当前位置                                                     |

#### 示例：读取文件最后10个字节
```cpp
#include <fstream>
#include <iostream>
using namespace std;

int main() {
  ifstream ifs("test.txt", ios::in | ios::binary);
  if (!ifs.is_open()) return -1;

  // 1. 移动读指针到文件末尾，获取文件大小
  ifs.seekg(0, ios::end);
  int fileSize = ifs.tellg(); // 文件总字节数

  // 2. 移动读指针到文件末尾前10个字节（若文件小于10字节则从开头开始）
  int offset = (fileSize > 10) ? -10 : 0;
  ifs.seekg(offset, ios::end);

  // 3. 读取剩余字节
  char buf[11] = {0}; // 存储10个字符+结束符
  ifs.read(buf, 10);
  cout << "文件最后10个字节：" << buf << endl;

  ifs.close();
  return 0;
}
```

### 6. 数据持久化注意事项
- 文本文件读写时，`string`类型可直接用`<<`/`>>`，但二进制文件不建议存储`string`（动态内存导致结构不固定），推荐用固定长度字符数组；
- 打开文件后必须检查是否成功（`is_open()`），避免因路径错误、权限问题导致后续操作失败；
- 操作完成后手动关闭文件（`close()`），或使用RAII封装（如自定义文件类，析构时自动关闭）；
- 二进制文件的跨平台兼容性：不同平台的字节序（大端/小端）、结构体对齐方式可能不同，需注意兼容性处理。

## 三、异常处理
异常处理是C++处理运行时错误（如除零、文件打开失败、内存分配失败）的机制，核心思想是“分离错误检测和错误处理”，让代码更健壮、可读性更高。

### 1. 核心语法：`try-catch-throw`
```cpp
try {
  // 可能抛出异常的代码块（错误检测）
  if (错误条件) {
    throw 异常值; // 抛出异常（可是任意类型：int、string、自定义类等）
  }
} catch (异常类型1& e) {
  // 处理异常类型1的逻辑（错误处理）
} catch (异常类型2& e) {
  // 处理异常类型2的逻辑
} catch (...) {
  // 捕获所有未匹配的异常（兜底处理）
}
```

#### 基础示例：除零异常处理
```cpp
#include <iostream>
#include <string>
using namespace std;

int divide(int a, int b) {
  if (b == 0) {
    // 抛出异常（这里抛出string类型）
    throw string("错误：除数不能为零！");
  }
  return a / b;
}

int main() {
  int x = 10, y = 0;
  try {
    int result = divide(x, y); // 可能抛出异常
    cout << "结果：" << result << endl;
  } catch (const string& err) { // 捕获string类型异常
    cout << "捕获到异常：" << err << endl; // 输出错误信息
  } catch (...) { // 兜底捕获
    cout << "捕获到未知异常！" << endl;
  }
  return 0;
}
```

### 2. 自定义异常类（推荐）
C++标准库提供了异常基类`exception`（定义在`<exception>`头文件中），自定义异常类建议继承`exception`，并重写`what()`方法（返回异常描述），便于统一处理。

#### 示例：自定义异常类
```cpp
#include <iostream>
#include <exception>
#include <string>
using namespace std;

// 自定义异常类：继承exception
class DivideException : public exception {
private:
  string msg;
public:
  // 构造函数：传入异常描述
  DivideException(const string& message) : msg(message) {}

  // 重写what()方法（必须是const noexcept）
  const char* what() const noexcept override {
    return msg.c_str(); // 返回C风格字符串
  }
};

int divide(int a, int b) {
  if (b == 0) {
    throw DivideException("除数不能为零！"); // 抛出自定义异常
  }
  if (b < 0) {
    throw runtime_error("除数不能为负数！"); // 抛出标准库异常
  }
  return a / b;
}

int main() {
  try {
    divide(10, -2);
  } catch (const DivideException& e) { // 捕获自定义异常
    cout << "自定义异常：" << e.what() << endl;
  } catch (const exception& e) { // 捕获所有继承自exception的异常
    cout << "标准库异常：" << e.what() << endl; // 输出：除数不能为负数！
  }
  return 0;
}
```

### 3. 标准库异常类
C++标准库提供了一系列预定义异常类，均继承自`exception`，常用如下：

| 异常类          | 头文件       | 含义                                                                 |
|-----------------|--------------|----------------------------------------------------------------------|
| `runtime_error` | `<stdexcept>` | 运行时错误（可避免的错误，如除数为负）                                 |
| `logic_error`   | `<stdexcept>` | 逻辑错误（编译时可检测的错误，如参数非法）                             |
| `bad_alloc`     | `<new>`      | `new`分配内存失败时抛出                                               |
| `bad_cast`      | `<typeinfo>` | 动态类型转换（`dynamic_cast`）失败时抛出                               |
| `out_of_range`  | `<stdexcept>` | 容器访问越界（如`vector::at()`）时抛出                                 |

#### 示例：使用标准库异常
```cpp
#include <vector>
#include <stdexcept>
#include <iostream>
using namespace std;

int main() {
  vector<int> vec = {1,2,3};
  try {
    vec.at(5); // 越界，抛出out_of_range异常
  } catch (const out_of_range& e) {
    cout << "异常：" << e.what() << endl; // 输出：invalid vector subscript
  }

  try {
    int* p = new int[1000000000000]; // 内存分配失败，抛出bad_alloc
  } catch (const bad_alloc& e) {
    cout << "内存分配失败：" << e.what() << endl;
  }
  return 0;
}
```

### 4. `noexcept`（C++11+）
`noexcept`是异常说明符，用于声明函数“不会抛出任何异常”，核心作用：
- 编译器可优化函数（如减少异常处理开销）；
- 明确函数的异常行为，便于调用者处理；
- 若声明`noexcept`的函数实际抛出异常，程序会调用`std::terminate()`终止（默认行为）。

#### 语法与示例
```cpp
// 声明函数不会抛出异常
void func1() noexcept {
  cout << "func1不会抛出异常" << endl;
}

// 条件 noexcept：当T的析构函数不抛出异常时，func2也不抛出
template <typename T>
void func2(T& obj) noexcept(noexcept(obj.~T())) {
  // ...
}

// 错误示例：声明noexcept但实际抛出异常
void func3() noexcept {
  throw runtime_error("错误"); // 程序会终止
}
```

#### 适用场景
- 析构函数（默认`noexcept`，C++11后）；
- 移动构造/移动赋值运算符（通常不抛出异常，用`noexcept`提升效率）；
- 简单函数（逻辑明确，无潜在异常）。

### 5. 异常处理最佳实践
- 只对“可恢复的运行时错误”使用异常（如文件打开失败、网络连接中断），逻辑错误（如数组越界）建议用断言（`assert`）；
- 异常类型优先使用自定义类（继承`exception`），便于分类处理；
- 抛出异常时，传递有意义的错误描述（便于调试）；
- 避免在析构函数中抛出异常（可能导致资源泄漏或程序终止）；
- 捕获异常时，遵循“具体到一般”的顺序（先捕获子类异常，再捕获基类异常）。

## 四、内存管理
内存管理是C++的核心难点，也是面试高频考点，核心目标是“合理分配内存、及时释放内存，避免内存泄漏、野指针等问题”。

### 1. 内存区域划分
C++程序运行时的内存空间分为5个区域，不同区域的内存生命周期、管理方式不同：

| 内存区域       | 存储内容                                                                 | 生命周期                | 管理方式                     |
|----------------|--------------------------------------------------------------------------|-------------------------|------------------------------|
| 栈（Stack）    | 局部变量、函数参数、返回值                                               | 超出作用域自动销毁      | 编译器自动管理（入栈/出栈）   |
| 堆（Heap）     | 动态分配的内存（`new`/`malloc`）                                         | 手动释放（`delete`/`free`） | 程序员手动管理               |
| 全局/静态存储区 | 全局变量、静态变量（`static`）                                           | 程序运行期间一直存在    | 编译器自动管理（程序启动分配，结束释放） |
| 常量存储区     | 字符串常量、`const`全局变量                                             | 程序运行期间一直存在    | 只读，编译器管理             |
| 代码区         | 程序的机器指令                                                           | 程序运行期间一直存在    | 只读，编译器管理             |

#### 关键区别：栈 vs 堆
| 对比维度       | 栈                     | 堆                     |
|----------------|------------------------|------------------------|
| 分配方式       | 编译器自动分配         | 程序员手动分配（`new`/`malloc`） |
| 释放方式       | 自动释放（出栈）       | 手动释放（`delete`/`free`） |
| 大小限制       | 较小（通常几MB）       | 较大（通常GB级）       |
| 分配效率       | 高（直接操作寄存器）   | 低（需操作系统介入）   |
| 内存碎片       | 无（连续分配）         | 有（频繁分配/释放导致） |
| 生长方向       | 向下生长（地址从高到低） | 向上生长（地址从低到高） |

### 2. `new/delete` 与 `malloc/free` 区别（面试核心）
`new/delete`是C++的运算符，`malloc/free`是C语言的函数，两者都用于堆内存分配，但`new/delete`更符合C++的面向对象特性：

| 对比维度       | `new/delete`                                                           | `malloc/free`                                                     |
|----------------|------------------------------------------------------------------------|------------------------------------------------------------------|
| 本质           | C++运算符                                                              | C语言标准库函数                                                   |
| 类型安全       | 分配时指定类型，返回对应类型指针（无需强制转换）                       | 返回`void*`，需手动强制转换为目标类型                             |
| 构造/析构      | `new`自动调用构造函数，`delete`自动调用析构函数                       | 仅分配/释放内存，不调用构造/析构（无法用于自定义类对象）           |
| 内存分配失败   | 抛出`bad_alloc`异常（C++11后）                                         | 返回`NULL`指针                                                   |
| 数组分配       | `new[]`分配数组，`delete[]`释放（必须匹配）                             | `malloc(n * sizeof(类型))`，需手动计算字节数                       |
| 自定义分配器   | 支持重载`operator new`/`operator delete`，自定义内存分配逻辑           | 不支持，只能使用系统默认分配逻辑                                   |

#### 示例对比
```cpp
// 1. 基础类型分配
int* p1 = new int(10); // new：分配+初始化，返回int*
int* p2 = (int*)malloc(sizeof(int)); // malloc：仅分配，返回void*需转换
*p2 = 10; // 手动初始化

delete p1; // 释放+调用析构（基础类型无析构，仅释放内存）
free(p2); // 仅释放内存

// 2. 数组分配
int* arr1 = new int[5]; // new[]：分配5个int的数组
int* arr2 = (int*)malloc(5 * sizeof(int)); // malloc：计算字节数

delete[] arr1; // 必须用delete[]，否则仅释放第一个元素（内存泄漏）
free(arr2);

// 3. 自定义类对象分配
class Person {
public:
  Person() { cout << "构造函数" << endl; }
  ~Person() { cout << "析构函数" << endl; }
};

Person* p3 = new Person; // new：分配内存+调用构造 → 输出"构造函数"
delete p3; // delete：调用析构+释放内存 → 输出"析构函数"

Person* p4 = (Person*)malloc(sizeof(Person)); // malloc：仅分配内存，不调用构造
free(p4); // 仅释放内存，不调用析构 → 资源泄漏（若类有堆资源）
```

### 3. 智能指针（`unique_ptr`/`shared_ptr`/`weak_ptr`）
智能指针是C++11+引入的核心特性，封装了原始指针，遵循RAII原则，自动管理堆内存（析构时自动释放），从根源上避免内存泄漏和野指针。

#### （1）`unique_ptr`（独占所有权）
- **核心特性**：同一时间只能有一个`unique_ptr`指向堆内存（独占所有权），不能拷贝，只能移动；
- **适用场景**：单个对象独占资源（如局部动态对象、函数返回动态对象）；
- **核心操作**：
  - `make_unique<T>(args)`：创建`unique_ptr`（推荐，比`new`更安全）；
  - `move(p)`：转移所有权（转移后原指针变为`nullptr`）；
  - `reset()`：释放当前资源，可重新绑定新指针；
  - `get()`：获取原始指针（谨慎使用，避免野指针）。

#### 示例
```cpp
#include <memory>
using namespace std;

int main() {
  // 创建unique_ptr（独占Person对象）
  unique_ptr<Person> p1 = make_unique<Person>();
  p1->showInfo();

  // 不能拷贝（编译错误）
  // unique_ptr<Person> p2 = p1;

  // 移动所有权
  unique_ptr<Person> p2 = move(p1);
  if (!p1) {
    cout << "p1已失去所有权" << endl;
  }

  // 重置指针（释放资源）
  p2.reset(); // 调用Person析构函数
  return 0;
} // p2析构时，若有资源则自动释放
```

#### （2）`shared_ptr`（共享所有权）
- **核心特性**：多个`shared_ptr`可指向同一堆内存，通过“引用计数”管理生命周期（引用计数为0时自动释放内存）；
- **适用场景**：多个对象共享资源（如容器存储动态对象、多线程共享数据）；
- **核心操作**：
  - `make_shared<T>(args)`：创建`shared_ptr`（推荐，内存分配更高效）；
  - `use_count()`：获取当前引用计数；
  - `reset()`：减少引用计数，若计数为0则释放资源；
  - `get()`：获取原始指针。

#### 示例
```cpp
#include <memory>
using namespace std;

int main() {
  // 创建shared_ptr（引用计数=1）
  shared_ptr<Person> p1 = make_shared<Person>();
  cout << "引用计数：" << p1.use_count() << endl; // 1

  // 拷贝指针（引用计数=2）
  shared_ptr<Person> p2 = p1;
  cout << "引用计数：" << p1.use_count() << endl; // 2

  // 重置p1（引用计数=1）
  p1.reset();
  cout << "引用计数：" << p2.use_count() << endl; // 1

  return 0;
} // p2析构，引用计数=0 → 释放Person对象（调用析构）
```

#### （3）`weak_ptr`（弱引用）
- **核心问题**：`shared_ptr`的循环引用（两个`shared_ptr`互相指向，导致引用计数永远不为0，内存泄漏）；
- **核心特性**：弱引用`shared_ptr`指向的资源，不增加引用计数，可通过`lock()`获取`shared_ptr`（判断资源是否存在）；
- **适用场景**：解决`shared_ptr`循环引用问题。

#### 循环引用示例（错误）
```cpp
class A;
class B;

class A {
public:
  shared_ptr<B> b_ptr; // A持有B的shared_ptr
  ~A() { cout << "A析构" << endl; }
};

class B {
public:
  shared_ptr<A> a_ptr; // B持有A的shared_ptr
  ~B() { cout << "B析构" << endl; }
};

int main() {
  shared_ptr<A> a = make_shared<A>();
  shared_ptr<B> b = make_shared<B>();
  a->b_ptr = b; // a指向b，引用计数=2
  b->a_ptr = a; // b指向a，引用计数=2

  return 0;
} // 引用计数均为1，不析构 → 内存泄漏！
```

#### 用`weak_ptr`解决循环引用（正确）
```cpp
class A {
public:
  weak_ptr<B> b_ptr; // 改为weak_ptr（不增加引用计数）
  ~A() { cout << "A析构" << endl; }
};

class B {
public:
  weak_ptr<A> a_ptr; // 改为weak_ptr
  ~B() { cout << "B析构" << endl; }
};

int main() {
  shared_ptr<A> a = make_shared<A>();
  shared_ptr<B> b = make_shared<B>();
  a->b_ptr = b; // weak_ptr不增加引用计数（b的计数仍为1）
  b->a_ptr = a; // weak_ptr不增加引用计数（a的计数仍为1）

  return 0;
} // a、b析构，引用计数=0 → A、B均析构（无内存泄漏）
```

### 4. 内存泄漏及避免
内存泄漏是指堆内存分配后未释放，导致内存被永久占用，最终耗尽系统内存。

#### 常见内存泄漏场景
- 忘记释放`new/malloc`分配的内存；
- `shared_ptr`循环引用；
- 异常抛出导致释放代码未执行（如`new`后抛出异常，`delete`未执行）；
- 动态分配的内存被覆盖（如`int* p = new int; p = new int;`，第一个`new`的内存泄漏）。

#### 内存泄漏避免方案
- 优先使用智能指针（`unique_ptr`/`shared_ptr`），避免手动管理`new/delete`；
- 避免`shared_ptr`循环引用（用`weak_ptr`）；
- 用RAII封装资源（如文件句柄、锁、动态内存）；
- 开发阶段使用内存检测工具（如Valgrind、Visual Studio内存诊断）；
- 统一内存分配/释放规范（如避免混合使用`new`和`free`）。

### 5. 内存管理最佳实践
- 优先使用栈内存（局部变量），栈内存自动管理，无泄漏风险；
- 动态内存优先使用智能指针，而非原始指针；
- 避免裸`new/delete`（尤其是在复杂逻辑中），若必须使用，确保`new`和`delete`成对出现（匹配`new[]`和`delete[]`）；
- 不返回局部变量的指针/引用（局部变量出栈后销毁，指针/引用变为野指针）；
- 动态数组优先使用`vector`（自动管理内存），而非`new[]`。

## 五、现代特性（C++11+）
C++11及后续标准引入了大量实用特性，大幅提升开发效率和代码可读性，是面试高频考点（尤其是C++11/14/17的核心特性）。

### 1. `auto`（自动类型推导）
- **核心作用**：编译器根据初始化表达式自动推导变量类型，简化代码书写（尤其是复杂类型，如迭代器、智能指针）；
- **核心规则**：
  - `auto`变量必须初始化（否则无法推导类型）；
  - 推导时会忽略顶层`const`（如需保留`const`，需显式声明`const auto`）；
  - 推导数组或函数时，会退化为指针（除非用`auto&`引用）。

#### 示例
```cpp
#include <vector>
#include <memory>
using namespace std;

int main() {
  // 基础类型推导
  auto a = 10; // a为int
  auto b = 3.14; // b为double
  auto c = "hello"; // c为const char*

  // 复杂类型推导（简化代码）
  vector<int> vec = {1,2,3};
  auto it = vec.begin(); // it为vector<int>::iterator（无需写长类型）

  auto p = make_shared<Person>(); // p为shared_ptr<Person>

  // 保留const
  const auto d = a; // d为const int
  auto e = d; // e为int（忽略顶层const）
  const auto& f = d; // f为const int&（引用保留const）

  // 数组推导（退化为指针）
  int arr[5] = {1,2,3,4,5};
  auto g = arr; // g为int*
  auto& h = arr; // h为int(&)[5]（引用不退化）

  return 0;
}
```

#### 适用场景
- 迭代器、智能指针等复杂类型变量；
- 匿名类型（如lambda表达式的返回值）；
- 简化代码书写，提升可读性（避免类型冗余）。

#### 禁忌场景
- 函数参数（`void func(auto x)` 不是标准C++，需用模板替代）；
- 类成员变量（不能用`auto`声明类成员）；
- 未初始化的变量（`auto x;` 编译错误）。

### 2. `decltype`（类型推导）
- **核心作用**：获取表达式的类型（无需初始化变量），与`auto`互补（`auto`推导变量类型，`decltype`推导表达式类型）；
- **核心规则**：
  - 若表达式是变量或函数调用，`decltype`直接返回其类型；
  - 若表达式是带括号的变量（如`decltype((x))`），返回引用类型；
  - 推导时保留`const`和引用属性。

#### 示例
```cpp
#include <vector>
using namespace std;

int add(int a, int b) { return a + b; }

int main() {
  int x = 10;
  const int y = 20;
  int& z = x;

  // 推导变量类型
  decltype(x) a = 5; // a为int
  decltype(y) b = 15; // b为const int
  decltype(z) c = x; // c为int&（引用）

  // 推导表达式类型
  decltype(x + y) d = 25; // x+y为int → d为int
  decltype(add(1,2)) e = 30; // add返回int → e为int

  // 带括号的变量（返回引用）
  decltype((x)) f = x; // f为int&（注意双层括号）
  f = 100;
  cout << x << endl; // x变为100

  // 结合模板使用（推导容器元素类型）
  vector<int> vec = {1,2,3};
  decltype(vec[0]) g = vec[0]; // g为int&（vector的[]返回引用）

  return 0;
}
```

#### 核心用途
- 模板中推导返回值类型（C++11前需用`typename`和`::type`，C++11后可结合`decltype`）；
- 定义与表达式类型一致的变量（避免类型冗余）；
- 配合`auto`实现泛型编程。

### 3. Lambda表达式（详细见STL章节）
Lambda是匿名函数，核心优势是“就地定义、就地使用”，无需单独声明函数，完美配合STL算法、回调函数等场景。

#### 核心补充：Lambda与函数指针的转换
- 无捕获的Lambda可隐式转换为函数指针；
- 有捕获的Lambda不能转换为函数指针（捕获的变量需要存储上下文）。

```cpp
// 无捕获Lambda转换为函数指针
void func(int (*ptr)(int, int)) {
  cout << ptr(1,2) << endl;
}

int main() {
  auto add = [](int a, int b){ return a + b; };
  func(add); // 合法：无捕获Lambda可转换为函数指针

  int x = 10;
  auto addX = [x](int a){ return a + x; };
  // func(addX); // 非法：有捕获Lambda不能转换为函数指针
  return 0;
}
```

### 4. 其他常用现代特性
#### （1）范围for循环（C++11+）
简化容器/数组的遍历，语法：`for (元素类型 变量名 : 容器/数组) { ... }`

```cpp
vector<int> vec = {1,2,3,4,5};
for (int num : vec) {
  cout << num << " "; // 输出1 2 3 4 5
}

// 修改元素（需用引用）
for (int& num : vec) {
  num *= 2; // vec变为[2,4,6,8,10]
}
```

#### （2）列表初始化（C++11+）
支持用`{}`初始化变量、数组、容器、类对象，统一初始化语法，更安全（避免窄化转换）。

```cpp
// 变量初始化
int a = {10};
int b{20}; // 可省略=

// 数组初始化
int arr[] = {1,2,3};
int arr2[]{4,5,6};

// 容器初始化
vector<int> vec = {1,2,3};
map<string, int> mp = {{"a",1}, {"b",2}};

// 类对象初始化（需支持列表初始化，或有对应的构造函数）
Person p{"Tom", 18};
```

#### （3）`nullptr`（C++11+）
专门表示空指针，替代C语言的`NULL`（`NULL`本质是`0`，可能引发歧义），是指针类型安全的空值表示。

```cpp
void func(int x) { cout << "int参数" << endl; }
void func(char* p) { cout << "char*参数" << endl; }

int main() {
  func(NULL); // 调用func(int)（NULL是0），可能不符合预期
  func(nullptr); // 调用func(char*)（nullptr是指针类型），正确
  return 0;
}
```

#### （4）`constexpr`（C++11+）
声明“编译期常量”或“编译期可计算函数”，核心作用是将计算提前到编译期，提升运行效率。

```cpp
// 编译期常量
constexpr int MAX = 100;
constexpr int MIN = MAX / 2; // 编译期计算为50

// 编译期函数（必须返回常量表达式，函数体无副作用）
constexpr int add(int a, int b) {
  return a + b;
}

int main() {
  constexpr int sum = add(1,2); // 编译期计算为3
  return 0;
}
```

### 5. 现代特性使用建议
- 优先使用`auto`简化复杂类型书写，但避免过度使用（影响代码可读性）；
- 列表初始化优先于传统初始化（`=`或括号），更安全、统一；
- Lambda优先用于短小的局部逻辑（如STL算法参数），复杂逻辑仍建议用命名函数；
- 新项目尽量使用C++11+标准，充分利用现代特性提升开发效率；
- 面试前重点掌握`auto`、`decltype`、Lambda、智能指针、`nullptr`等核心现代特性。
