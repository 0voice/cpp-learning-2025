# 面向对象篇
## 一、类与对象
### 1. 类与结构体（`class` vs `struct`）
C++ 中 `class` 和 `struct` 是面向对象的核心载体，核心区别仅在于**默认访问控制权限**，语法几乎完全一致：

| 特性                | `class`                          | `struct`                          |
|---------------------|----------------------------------|----------------------------------|
| 默认访问控制        | `private`（私有）                | `public`（公有）                 |
| 继承默认权限        | 私有继承（`private inheritance`） | 公有继承（`public inheritance`）  |
| 核心用途            | 封装复杂对象（侧重行为+属性）    | 封装简单数据结构（侧重属性）      |
| 支持特性            | 成员变量、成员函数、继承、多态等（与`struct`完全一致） | 同class |

- **示例：`class` 定义**
  ```cpp
  // 类的定义（通常放在头文件.h中）
  class Person {
  // 访问控制修饰符（可多次出现，作用域到下一个修饰符为止）
  private:
    // 私有成员：仅类内部可访问（封装的核心，隐藏实现细节）
    string name;
    int age;

  public:
    // 公有成员：类外部可访问（提供对外接口）
    // 成员函数（行为）
    void setInfo(string n, int a) {
      name = n;
      age = a;
    }

    void showInfo() {
      cout << "姓名：" << name << "，年龄：" << age << endl;
    }
  };
  ```

- **示例：`struct` 定义**
  ```cpp
  struct Student {
    // 默认public，可直接访问成员变量
    string id;
    string name;

    // 结构体也支持成员函数
    void show() {
      cout << "学号：" << id << "，姓名：" << name << endl;
    }
  };

  // 外部直接访问struct成员（默认public）
  Student s;
  s.id = "2024001";
  s.name = "Tom";
  s.show();
  ```

### 2. 成员变量与成员函数
- **成员变量**：类/结构体中定义的变量（存储对象的状态）；
- **成员函数**：类/结构体中定义的函数（描述对象的行为）；
- **访问控制规则**（封装的核心，实现“数据隐藏”）：
  - `public`：公有成员，类内、类外、派生类均可访问（对外提供的接口）；
  - `private`：私有成员，仅类内可访问（隐藏内部实现，外部无法直接修改）；
  - `protected`：保护成员，类内、派生类可访问，类外不可访问（为继承设计）；
- **面试考点**：封装的意义——通过`private`隐藏内部状态，仅通过`public`接口交互，保证数据安全性和代码可维护性。

### 3. 对象创建：栈上 vs 堆上
对象是类的实例化产物，创建方式分为两种，核心区别在于**内存分配位置**和**生命周期管理**：

| 创建方式 | 内存位置 | 生命周期                | 语法示例                          | 访问方式       |
|----------|----------|-------------------------|-----------------------------------|----------------|
| 栈上创建 | 栈内存   | 超出作用域自动销毁      | `Person p;`（无`new`）            | 直接用`.`访问  |
| 堆上创建 | 堆内存   | 需手动用`delete`销毁    | `Person* p = new Person;`（用`new`） | 指针用`->`访问 |

- **示例：栈上对象**
  ```cpp
  void test() {
    Person p; // 栈上创建，作用域为test()函数内
    p.setInfo("Jerry", 22); // 栈对象用.访问成员
    p.showInfo();
  } // 函数结束，栈对象自动销毁（调用析构函数）
  ```

- **示例：堆上对象**
  ```cpp
  int main() {
    // 堆上创建对象，返回指向对象的指针
    Person* p = new Person;
    p->setInfo("Alice", 25); // 堆对象（指针）用->访问成员
    p->showInfo();

    // 必须手动delete销毁，否则内存泄漏
    delete p;
    p = nullptr; // 避免野指针
    return 0;
  }
  ```

- **核心注意**：堆上创建的对象必须用`delete`销毁（匹配`new`），否则会导致**内存泄漏**（堆内存不会自动释放）。

## 二、构造与析构
### 1. 构造函数（Constructor）
- **核心作用**：对象创建时自动调用，用于初始化成员变量（解决“成员变量默认未初始化”的问题）；
- **核心特性**：
  1. 函数名与类名完全一致；
  2. 无返回值类型（连`void`都不写）；
  3. 可重载（支持多个构造函数，参数列表不同）；
  4. 若未显式定义，编译器会生成**默认构造函数**（无参、空实现）；

#### （1）默认构造函数
- 无参数的构造函数（显式定义或编译器自动生成）；
- 示例：
  ```cpp
  class Person {
  private:
    string name;
    int age;
  public:
    // 显式定义默认构造函数
    Person() {
      name = "未知";
      age = 0;
    }
  };

  Person p; // 调用默认构造函数，name="未知"，age=0
  ```

#### （2）带参构造函数
- 带参数的构造函数，用于初始化时直接赋值；
- 示例：
  ```cpp
  class Person {
  private:
    string name;
    int age;
  public:
    // 带参构造函数（重载）
    Person(string n, int a) {
      name = n;
      age = a;
    }
  };

  // 创建对象时传参，调用带参构造
  Person p("Bob", 28);
  p.showInfo(); // 输出：姓名：Bob，年龄：28
  ```

#### （3）拷贝构造函数（Copy Constructor）
- **核心作用**：用一个已存在的对象初始化新对象（如对象赋值、函数值传递）；
- **语法**：`类名(const 类名& 源对象)`（参数必须是const引用，避免无限递归）；
- **默认行为**：若未显式定义，编译器生成**浅拷贝构造函数**（逐字节复制成员变量）；
- 示例：
  ```cpp
  class Person {
  private:
    string name;
    int age;
  public:
    // 显式定义拷贝构造函数
    Person(const Person& other) {
      this->name = other.name; // this指针：指向当前对象自身
      this->age = other.age;
      cout << "拷贝构造函数被调用" << endl;
    }
  };

  Person p1("Charlie", 30);
  Person p2 = p1; // 调用拷贝构造函数（用p1初始化p2）
  Person p3(p1);  // 等价于p2，同样调用拷贝构造
  ```

#### （4）移动构造函数（Move Constructor，C++11+）
- **核心背景**：解决“临时对象拷贝导致的性能浪费”（如函数返回局部对象时）；
- **核心作用**：“窃取”源对象的资源（如堆内存），而非拷贝，提升效率；
- **语法**：`类名(类名&& 源对象)`（参数是右值引用`&&`）；
- **默认行为**：未显式定义时，编译器不会自动生成（需手动实现）；
- 示例（含堆内存资源）：
  ```cpp
  class String {
  private:
    char* data; // 堆内存存储字符串
  public:
    // 带参构造（分配堆内存）
    String(const char* str) {
      int len = strlen(str);
      data = new char[len + 1];
      strcpy(data, str);
    }

    // 移动构造函数（窃取other的data）
    String(String&& other) noexcept { // noexcept：保证不抛异常
      this->data = other.data; // 直接接管资源
      other.data = nullptr; // 源对象置空，避免析构时重复释放
      cout << "移动构造函数被调用" << endl;
    }

    // 析构函数（释放堆内存）
    ~String() {
      delete[] data;
    }
  };

  // 函数返回局部对象（临时对象，右值）
  String createString() {
    return String("Hello");
  }

  String s = createString(); // 调用移动构造，而非拷贝（无堆内存重复分配）
  ```

### 2. 移动赋值运算符（C++11+）
- **核心作用**：用一个右值对象“赋值”给当前对象，同样是“窃取”资源而非拷贝；
- **语法**：`类名& operator=(类名&& other) noexcept`；
- 示例（承接上面`String`类）：
  ```cpp
  String& operator=(String&& other) noexcept {
    if (this != &other) { // 避免自赋值
      delete[] this->data; // 释放当前对象原有资源
      this->data = other.data; // 接管源对象资源
      other.data = nullptr; // 源对象置空
      cout << "移动赋值运算符被调用" << endl;
    }
    return *this;
  }

  String s1("World");
  s1 = createString(); // 调用移动赋值（窃取临时对象资源）
  ```

### 3. 析构函数（Destructor）
- **核心作用**：对象销毁时自动调用，用于释放资源（如堆内存、文件句柄、网络连接）；
- **核心特性**：
  1. 函数名前加`~`，与类名一致；
  2. 无返回值、无参数（不能重载，一个类只能有一个析构函数）；
  3. 若未显式定义，编译器生成默认析构函数（空实现）；
- **示例（释放堆内存）**：
  ```cpp
  class Person {
  private:
    string* name; // 堆上的字符串指针
  public:
    // 构造函数：分配堆内存
    Person(string n) {
      name = new string(n);
    }

    // 析构函数：释放堆内存（避免内存泄漏）
    ~Person() {
      delete name; // 释放name指向的堆内存
      cout << "析构函数被调用" << endl;
    }
  };

  Person p("David"); // 构造时分配堆内存
  // 函数结束，p销毁，析构函数自动调用，释放堆内存
  ```

### 4. 虚析构函数（面试高频）
- **核心问题**：当基类指针指向派生类对象时，若基类析构函数非虚函数，销毁对象时只会调用基类析构，派生类析构不会执行，导致**资源泄漏**；
- **核心作用**：确保派生类对象通过基类指针销毁时，先调用派生类析构，再调用基类析构；
- **语法**：在基类析构函数前加`virtual`；
- 示例（对比非虚析构与虚析构）：
  ```cpp
  // 基类
  class Base {
  public:
    // 非虚析构（错误示范）
    ~Base() {
      cout << "Base析构" << endl;
    }
  };

  // 派生类（含堆资源）
  class Derived : public Base {
  private:
    int* data;
  public:
    Derived() {
      data = new int(10);
    }
    ~Derived() {
      delete data; // 释放派生类的堆资源
      cout << "Derived析构" << endl;
    }
  };

  // 测试：基类指针指向派生类对象
  Base* ptr = new Derived;
  delete ptr; // 仅调用Base析构，Derived析构未执行 → 内存泄漏！
  ```

- **修正（虚析构）**：
  ```cpp
  class Base {
  public:
    virtual ~Base() { // 基类析构设为virtual
      cout << "Base析构" << endl;
    }
  };

  Base* ptr = new Derived;
  delete ptr; 
  // 正确执行顺序：Derived析构 → Base析构（无内存泄漏）
  ```

- **面试考点**：虚析构的必要性——只要类可能被继承，且派生类有堆资源，基类析构必须设为`virtual`；抽象类（含纯虚函数）的析构也需设为虚析构（可提供默认实现）。

### 5. 初始化列表（Initializer List）
- **核心作用**：在构造函数体执行前，直接初始化成员变量（比构造函数体内赋值更高效，尤其适合`const`成员、引用成员、没有默认构造的对象成员）；
- **语法**：`构造函数(参数列表) : 成员1(值1), 成员2(值2), ... {}`；
- 示例：
  ```cpp
  class Person {
  private:
    const string name; // const成员（必须初始化，不能赋值）
    int& age; // 引用成员（必须初始化，不能改绑）
    string addr;
  public:
    // 初始化列表初始化成员（唯一能初始化const和引用的方式）
    Person(string n, int& a, string ad) : name(n), age(a), addr(ad) {
      // 构造函数体：可做其他逻辑（如参数校验）
      if (a < 0) throw invalid_argument("年龄不能为负");
    }
  };

  int age = 25;
  Person p("Eve", age, "Beijing"); // 正确初始化const、引用、普通成员
  ```

- **优势**：
  1. 效率更高：直接初始化成员，避免“先默认构造再赋值”的额外开销；
  2. 功能更强：支持`const`、引用、无默认构造的成员初始化；
- **面试考点**：初始化列表的执行顺序——与成员变量在类中的**声明顺序一致**，而非初始化列表中的顺序。

### 6. RAII原则（Resource Acquisition Is Initialization）
- **核心思想**：“资源获取即初始化”——将资源（堆内存、文件句柄、锁等）的生命周期与对象的生命周期绑定：
  - 对象创建时（构造函数）获取资源；
  - 对象销毁时（析构函数）自动释放资源；
- **核心价值**：无需手动管理资源，从根源上避免内存泄漏、资源泄漏；
- **典型应用**：
  - 智能指针（`unique_ptr`/`shared_ptr`）：封装堆内存，析构时自动`delete`；
  - 锁管理（`lock_guard`）：构造时加锁，析构时自动解锁；
- 示例（RAII封装文件句柄）：
  ```cpp
  class FileGuard {
  private:
    FILE* file; // 资源：文件句柄
  public:
    // 构造时获取资源（打开文件）
    FileGuard(const char* path, const char* mode) {
      file = fopen(path, mode);
      if (!file) throw runtime_error("文件打开失败");
    }

    // 析构时释放资源（关闭文件）
    ~FileGuard() {
      if (file) fclose(file);
    }

    // 提供访问接口
    FILE* getFile() const { return file; }
  };

  // 使用：无需手动关闭文件
  void readFile() {
    FileGuard fg("test.txt", "r"); // 打开文件（获取资源）
    fread(..., fg.getFile()); // 操作文件
  } // fg销毁，析构函数自动关闭文件（释放资源）
  ```

### 7. 智能指针初步认识
智能指针是RAII原则的典型实现，封装了原始指针，自动管理堆内存（析构时自动`delete`），避免野指针和内存泄漏：

| 智能指针类型 | 核心特性 | 适用场景 | 语法示例 |
|--------------|----------|----------|----------|
| `unique_ptr` | 独占所有权（不能拷贝，只能移动） | 单个对象独占资源 | `unique_ptr<Person> p(new Person);` |
| `shared_ptr` | 共享所有权（引用计数，计数为0时释放） | 多个对象共享资源 | `shared_ptr<Person> p = make_shared<Person>();` |
| `weak_ptr` | 弱引用（不增加引用计数，解决`shared_ptr`循环引用） | 辅助`shared_ptr`，避免循环引用 | `weak_ptr<Person> wp = p;` |

- **示例：`unique_ptr`（独占指针）**
  ```cpp
  #include <memory> // 必须包含智能指针头文件

  int main() {
    // 方式1：创建unique_ptr（独占Person对象）
    unique_ptr<Person> p1(new Person("Frank", 35));
    p1->showInfo(); // 用->访问成员

    // 方式2：推荐用make_shared（更安全，避免内存泄漏）
    auto p2 = make_unique<Person>("Grace", 32);

    // 不能拷贝（独占所有权）
    // unique_ptr<Person> p3 = p1; // 编译错误

    // 可以移动（转移所有权）
    unique_ptr<Person> p3 = move(p1); // p1失去所有权，变为nullptr
    p3->showInfo();

    return 0;
  } // p3、p2销毁，自动调用delete释放堆内存
  ```

- **核心优势**：无需手动`delete`，即使程序抛出异常，对象也会被析构（栈对象的析构顺序）。

### 8. Rule of Five（五大法则）
C++11后扩展自“三大法则”（Rule of Three），核心规则：

> 若类中显式定义了以下任意一个成员，必须显式定义其余四个，否则可能导致资源管理错误：
> 1. 析构函数（`~类名()`）；
> 2. 拷贝构造函数（`类名(const 类名&)`）；
> 3. 拷贝赋值运算符（`operator=(const 类名&)`）；
> 4. 移动构造函数（`类名(类名&&)`）；
> 5. 移动赋值运算符（`operator=(类名&&)`）；

- **核心原因**：显式定义析构函数通常意味着类管理了资源（堆内存等），默认的拷贝/移动语义是“浅拷贝”，会导致资源重复释放或内存泄漏；
- **简化方案**：
  - 若不需要拷贝/移动：显式删除（`= delete`）拷贝/移动相关函数；
  - 若需要：手动实现深拷贝/移动语义；
- 示例（删除拷贝，保留移动）：
  ```cpp
  class String {
  public:
    // 拷贝构造和拷贝赋值删除（禁止拷贝）
    String(const String&) = delete;
    String& operator=(const String&) = delete;

    // 移动构造和移动赋值实现（允许移动）
    String(String&&) noexcept;
    String& operator=(String&&) noexcept;

    // 析构函数
    ~String();
  };
  ```

## 三、继承与多态
### 1. 继承语法与基类/派生类
- **核心思想**：“复用已有类的属性和行为”，同时允许派生类扩展或修改基类功能；
- **术语定义**：
  - 基类（父类）：被继承的类；
  - 派生类（子类）：继承基类的类；
- **继承语法**：`class 派生类名 : 继承方式 基类名 { ... };`
- **继承方式（访问控制）**：

| 继承方式 | 基类public成员 | 基类protected成员 | 基类private成员 |
|----------|----------------|------------------|----------------|
| public（公有继承） | 派生类public | 派生类protected | 不可访问 |
| protected（保护继承） | 派生类protected | 派生类protected | 不可访问 |
| private（私有继承） | 派生类private | 派生类private | 不可访问 |

- **示例：公有继承（最常用）**
  ```cpp
  // 基类（父类）
  class Animal {
  protected: // 保护成员：派生类可访问
    string name;
  public:
    Animal(string n) : name(n) {}

    // 基类成员函数
    void eat() {
      cout << name << " 在吃东西" << endl;
    }
  };

  // 派生类（子类）：公有继承Animal
  class Dog : public Animal {
  private:
    string breed; // 派生类新增成员
  public:
    // 派生类构造函数：必须先初始化基类（用初始化列表）
    Dog(string n, string b) : Animal(n), breed(b) {}

    // 派生类扩展功能
    void bark() {
      cout << name << "（" << breed << "）在叫：汪汪汪" << endl;
    }

    // 派生类重写基类函数（覆盖）
    void eat() override { // override关键字：确保重写基类虚函数（C++11+）
      cout << name << " 在吃狗粮" << endl;
    }
  };

  // 使用派生类
  Dog dog("旺财", "金毛");
  dog.eat(); // 调用派生类重写的eat() → 旺财在吃狗粮
  dog.bark(); // 调用派生类新增的bark() → 旺财（金毛）在叫：汪汪汪
  ```

- **核心规则**：派生类构造函数必须先初始化基类（通过初始化列表），析构函数执行顺序与构造相反（派生类析构 → 基类析构）。

### 2. 虚函数（`virtual`）
- **核心作用**：实现多态的基础——允许派生类重写基类函数，基类指针/引用指向派生类对象时，调用的是派生类的重写版本；
- **语法**：基类函数前加`virtual`，派生类重写时可加`override`（可选，但推荐，避免重写错误）；
- **示例：虚函数实现多态**
  ```cpp
  class Animal {
  public:
    virtual void makeSound() { // 基类虚函数
      cout << "动物发出声音" << endl;
    }
  };

  class Cat : public Animal {
  public:
    void makeSound() override { // 重写虚函数
      cout << "猫咪叫：喵喵喵" << endl;
    }
  };

  class Dog : public Animal {
  public:
    void makeSound() override { // 重写虚函数
      cout << "狗狗叫：汪汪汪" << endl;
    }
  };

  int main() {
    Animal* animal1 = new Dog();
    Animal* animal2 = new Cat();

    animal1->makeSound(); // 调用Dog的makeSound() → 汪汪汪（多态）
    animal2->makeSound(); // 调用Cat的makeSound() → 喵喵喵（多态）

    delete animal1; // 虚析构确保正确释放
    delete animal2;
    return 0;
  }
  ```

- **底层原理**：基类含有虚函数时，编译器会为类生成**虚函数表（vtable）**，存储虚函数的地址；每个对象会包含一个**虚表指针（vptr）**，指向所属类的vtable；调用虚函数时，通过vptr查找vtable，找到实际要调用的函数地址（动态绑定）。

### 3. 纯虚函数与抽象类
- **纯虚函数**：没有函数体的虚函数，语法为`virtual 返回值类型 函数名(参数列表) = 0;`；
- **抽象类**：包含纯虚函数的类（不能实例化对象，只能作为基类被继承）；
- **核心作用**：定义接口规范，强制派生类实现特定功能；
- 示例：
  ```cpp
  // 抽象类（含纯虚函数）
  class Shape {
  public:
    virtual double getArea() = 0; // 纯虚函数：计算面积（接口）
    virtual double getPerimeter() = 0; // 纯虚函数：计算周长（接口）
    virtual ~Shape() {} // 虚析构（必须，避免派生类资源泄漏）
  };

  // 派生类必须实现所有纯虚函数，否则仍是抽象类
  class Circle : public Shape {
  private:
    double radius;
  public:
    Circle(double r) : radius(r) {}

    double getArea() override {
      return 3.14159 * radius * radius;
    }

    double getPerimeter() override {
      return 2 * 3.14159 * radius;
    }
  };

  // 使用抽象类（基类指针指向派生类对象）
  Shape* circle = new Circle(5.0);
  cout << "圆面积：" << circle->getArea() << endl; // 196.349
  cout << "圆周长：" << circle->getPerimeter() << endl; // 31.4159
  ```

- **面试考点**：抽象类不能实例化，但可以定义指针/引用；派生类必须实现所有纯虚函数才能实例化。

### 4. vtable简介（虚函数表）
- **核心概念**：vtable是编译器为含有虚函数的类生成的静态数组，存储该类所有虚函数的地址；
- **核心机制**：
  1. 每个对象包含一个`vptr`（虚表指针，通常在对象内存的最前面），指向所属类的vtable；
  2. 基类有vtable，派生类若重写虚函数，会替换vtable中对应函数的地址；若新增虚函数，会追加到vtable末尾；
  3. 调用虚函数时，通过`vptr`找到vtable，再通过函数索引找到实际函数地址（动态绑定，运行时确定调用哪个版本）；
- **内存结构示例**（`Animal`基类，`Dog`派生类）：
  ```
  Animal类vtable：
  [0] → Animal::makeSound()
  [1] → Animal::~Animal()

  Dog类vtable（重写makeSound）：
  [0] → Dog::makeSound()（替换基类函数）
  [1] → Animal::~Animal()（继承基类虚析构）
  ```

- **面试考点**：
  - 含有虚函数的类，对象大小会增加（多一个vptr的大小，32位系统4字节，64位8字节）；
  - 虚函数调用比普通函数慢（多一次vptr查找和间接跳转）；
  - 构造函数不能是虚函数（对象未完全创建时，vptr未初始化）；
  - 析构函数可以是虚函数（且推荐设为虚函数）。

## 四、运算符重载
### 1. 核心概念
- **作用**：赋予运算符新的语义，让自定义类型（如类、结构体）支持运算符操作（如`+`、`==`、`<<`）；
- **本质**：特殊的函数，函数名格式为`operator运算符`；
- **规则**：
  1. 不能重载的运算符：`.`、`.*`、`::`、`? :`、`sizeof`、`typeid`等；
  2. 重载后运算符的优先级、结合性、操作数个数不变；
  3. 必须与自定义类型相关（不能重载内置类型的运算符，如`int+int`）；

### 2. 赋值运算符重载（`operator=`）
- **核心作用**：自定义对象赋值的逻辑（默认是浅拷贝，需手动实现深拷贝避免资源泄漏）；
- **语法**：`类名& operator=(const 类名& 源对象);`
- **注意事项**：
  1. 必须返回`*this`（支持链式赋值，如`a = b = c`）；
  2. 必须检查自赋值（`this == &源对象`），避免重复释放资源；
  3. 先释放当前对象的资源，再拷贝源对象资源；
- 示例（深拷贝赋值）：
  ```cpp
  class String {
  private:
    char* data;
    int length;
  public:
    // 赋值运算符重载（深拷贝）
    String& operator=(const String& other) {
      // 1. 检查自赋值
      if (this == &other) return *this;

      // 2. 释放当前对象资源
      delete[] data;

      // 3. 深拷贝源对象资源
      length = other.length;
      data = new char[length + 1];
      strcpy(data, other.data);

      // 4. 返回*this（链式赋值）
      return *this;
    }

    ~String() {
      delete[] data;
    }
  };

  // 使用
  String s1("Hello");
  String s2("World");
  s1 = s2; // 调用赋值运算符重载（深拷贝，无内存泄漏）
  String s3 = s1 = s2; // 链式赋值（支持）
  ```

### 3. 算术运算符重载（`+`、`-`等）
- 通常重载为**成员函数**或**全局函数**（推荐全局函数，支持交换律，如`a + b`和`b + a`）；
- 示例：重载`+`实现两个`Point`对象相加（坐标相加）
  ```cpp
  class Point {
  private:
    int x, y;
  public:
    Point(int x_, int y_) : x(x_), y(y_) {}

    // 方式1：成员函数重载+（左操作数是this）
    Point operator+(const Point& other) const {
      return Point(this->x + other.x, this->y + other.y);
    }

    // 友元函数：允许全局函数访问私有成员（后续讲解）
    friend ostream& operator<<(ostream& os, const Point& p);
  };

  // 方式2：全局函数重载+（支持交换律，如3 + point）
  Point operator+(int val, const Point& p) {
    return Point(p.x + val, p.y + val);
  }

  // 使用
  Point p1(1, 2), p2(3, 4);
  Point p3 = p1 + p2; // 调用成员函数operator+ → (4,6)
  Point p4 = 5 + p1;  // 调用全局函数operator+ → (6,7)
  ```

### 4. 关系运算符重载（`==`、`!=`等）
- 通常重载为全局函数，返回`bool`类型；
- 示例：重载`==`和`!=`判断`Point`对象是否相等
  ```cpp
  bool operator==(const Point& p1, const Point& p2) {
    return p1.x == p2.x && p1.y == p2.y;
  }

  bool operator!=(const Point& p1, const Point& p2) {
    return !(p1 == p2); // 复用==的逻辑，避免冗余
  }

  // 使用
  if (p1 == p2) {
    cout << "p1和p2相等" << endl;
  } else {
    cout << "p1和p2不相等" << endl;
  }
  ```

### 5. 输出运算符重载（`operator<<`）
- `cout`是`ostream`类的对象，`<<`是`ostream`的成员函数；
- 重载`<<`需作为**全局函数**（左操作数是`ostream&`，而非自定义类对象）；
- 需通过`friend`（友元）允许函数访问自定义类的私有成员；
- 示例（承接`Point`类）：
  ```cpp
  // 全局函数+友元：重载<<，支持cout << Point对象
  ostream& operator<<(ostream& os, const Point& p) {
    os << "(" << p.x << ", " << p.y << ")"; // 访问p的私有成员x、y
    return os; // 返回os，支持链式输出（如cout << p1 << p2）
  }

  // 使用
  cout << "p1: " << p1 << ", p2: " << p2 << endl;
  // 输出：p1: (1, 2), p2: (3, 4)
  ```

### 6. 深拷贝与浅拷贝（面试核心）
- **浅拷贝**（默认拷贝/赋值语义）：
  - 仅复制成员变量的“值”，若成员变量是指针（指向堆内存），则拷贝后两个指针指向同一块内存；
  - 危害：析构时会重复释放同一块内存，导致程序崩溃；
- **深拷贝**（手动实现拷贝/赋值）：
  - 不仅复制成员变量的值，还为指针成员重新分配堆内存，并复制内存中的内容；
  - 效果：两个对象的指针成员指向不同的堆内存，析构时各自释放，无冲突；
- **示例对比**：
  ```cpp
  // 浅拷贝（默认行为，错误示范）
  class StringShallow {
  private:
    char* data;
  public:
    StringShallow(const char* str) {
      data = new char[strlen(str) + 1];
      strcpy(data, str);
    }
    // 未显式定义拷贝构造和赋值运算符（默认浅拷贝）
    ~StringShallow() { delete[] data; }
  };

  StringShallow s1("Hello");
  StringShallow s2 = s1; // 浅拷贝：s1.data和s2.data指向同一块内存
  // 函数结束，s2析构释放data → s1析构时再次释放 → 程序崩溃！

  // 深拷贝（正确实现）
  class StringDeep {
  private:
    char* data;
  public:
    StringDeep(const char* str) {
      data = new char[strlen(str) + 1];
      strcpy(data, str);
    }
    // 深拷贝构造
    StringDeep(const StringDeep& other) {
      data = new char[strlen(other.data) + 1];
      strcpy(data, other.data);
    }
    // 深拷贝赋值
    StringDeep& operator=(const StringDeep& other) {
      if (this != &other) {
        delete[] data;
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
      }
      return *this;
    }
    ~StringDeep() { delete[] data; }
  };

  StringDeep s3("World");
  StringDeep s4 = s3; // 深拷贝：s3.data和s4.data指向不同内存 → 无崩溃
  ```

- **面试考点**：深拷贝与浅拷贝的区别、默认拷贝/赋值的问题、如何实现深拷贝。

## 五、模板基础
### 1. 函数模板（Function Template）
- **核心作用**：定义“通用函数”，支持多种数据类型，避免重复编写同逻辑不同类型的函数（如`int`求和、`double`求和）；
- **语法**：`template <typename T>` 或 `template <class T>`（`typename`和`class`等价）；
- 示例：通用求和函数
  ```cpp
  // 函数模板：T是模板参数（类型占位符）
  template <typename T>
  T add(T a, T b) {
    return a + b;
  }

  int main() {
    // 方式1：编译器自动推导类型
    int sum1 = add(1, 2); // T=int → 返回3
    double sum2 = add(1.5, 2.5); // T=double → 返回4.0

    // 方式2：显式指定类型
    int sum3 = add<int>(3, 4); // 显式指定T=int
    return 0;
  }
  ```

- **模板实例化**：编译器遇到`add(1,2)`时，会自动生成`int add(int a, int b)`的具体实现（实例化），模板本身不会生成代码。

### 2. 类模板（Class Template）
- **核心作用**：定义“通用类”，类的成员变量/函数可以是模板类型；
- **语法**：`template <typename T>` 声明模板，类名后可加模板参数；
- 示例：通用栈类（支持任意类型元素）
  ```cpp
  template <typename T, int Size = 100> // 模板参数+默认值
  class Stack {
  private:
    T data[Size]; // 模板类型数组
    int top;
  public:
    Stack() : top(-1) {}

    void push(const T& val) {
      if (top < Size - 1) data[++top] = val;
    }

    T pop() {
      if (top >= 0) return data[top--];
      throw runtime_error("栈空");
    }

    bool isEmpty() const {
      return top == -1;
    }
  };

  // 使用
  int main() {
    // 栈1：int类型，默认大小100
    Stack<int> intStack;
    intStack.push(10);
    intStack.push(20);
    cout << intStack.pop() << endl; // 20

    // 栈2：double类型，大小50
    Stack<double, 50> doubleStack;
    doubleStack.push(3.14);
    cout << doubleStack.pop() << endl; // 3.14

    return 0;
  }
  ```

- **注意**：类模板的成员函数若在类外定义，需重新声明模板参数：
  ```cpp
  template <typename T, int Size>
  void Stack<T, Size>::push(const T& val) {
    // 类外实现...
  }
  ```

### 3. STL容器底层关联
STL（标准模板库）的核心是“模板化”设计，所有容器（`vector`、`list`、`map`等）本质都是**类模板**，支持任意可拷贝的类型：
- `vector<int>`：模板参数`T=int`的动态数组；
- `map<string, int>`：模板参数`key=string`、`value=int`的关联容器；
- 模板的优势：STL容器无需为每种数据类型单独实现，仅通过模板参数适配所有类型，实现“一次编写，多次复用”。

- **面试考点**：
  - 函数模板与函数重载的区别（模板是“通用类型”，重载是“不同参数列表”）；
  - 类模板的实例化方式（显式指定类型）；
  - 模板的局限性（需类型支持模板中使用的运算符，如`add`模板需`T`支持`+`）。
